module.exports=function(t){var e={};function n(a){if(e[a])return e[a].exports;var i=e[a]={i:a,l:!1,exports:{}};return t[a].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,a){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:a})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(a,i,function(e){return t[e]}.bind(null,i));return a},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="/",n(n.s=0)}([function(t,e,n){var a,i,o,s,r,l,c=function(t,e){if(!(t instanceof e))throw new Error("Bound instance method accessed before binding")};({h:r,Component:i}=n(1)),({Shader:s,Box:a}=n(2)),l=n(3),o=class t extends i{constructor(){super(...arguments),this.onClick=this.onClick.bind(this),this.draw=this.draw.bind(this)}componentDidMount(){if(this._t=.1,this.base.width=50,this.base.height=50,this.box=new a({canvas:this.base,resize:!1,clearColor:[0,0,0,0],uv:[1,1],context:{premultipliedAlpha:!1,antialias:!1,depth:!1}}),this.shader=new s({source:l,uniforms:{iTime:{type:"1f",value:0},alpha:{type:"1f",value:0}}}),this.stage={alpha:-4,time:-1},this.state={alpha:1,time:1},this.box.add(this.shader),!this._anim)return this._anim=!0,this.draw()}onClick(){return c(this,t),this.stage.time<0?this.state.time=1:this.state.time=-1,this.draw()}draw(){if(c(this,t),this.base&&!(Math.abs(this.stage.time-this.state.time)<.01&&Math.abs(this.stage.alpha-this.state.alpha)<.01))return this.stage.time+=.1*(this.state.time-this.stage.time),this.stage.alpha+=.3*(this.state.alpha-this.stage.alpha),this.shader.uniforms.iTime.value=this.stage.time,this.shader.uniforms.alpha.value=this.stage.alpha,requestAnimationFrame(this.draw),this.box.clear().draw(this.shader)}render(){return r("canvas",{style:{cursor:"pointer"},onClick:this.onClick,width:50,height:50})}},t.exports=o},function(t,e){t.exports=require("preact")},function(t,e){t.exports=require("shader-box")},function(t,e){t.exports="precision highp float;\n\nvarying vec2 v_uv;\n\nuniform float iTime;\n\nuniform float alpha;\n\n\n#define SPEED 0.01\n#define PI 3.141593\n\n\n//signed distance to a 2D triangle by iq : https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p ){\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat pit = PI*2.0/3.0; \n\nfloat a0 = 0.*PI*2.0/3.0;\nfloat a1 = 1.*PI*2.0/3.0; \nfloat a2 = 2.*PI*2.0/3.0;\n\n\nfloat b = 0.01;\nfloat r = 0.2;\n\n\nfloat drawStar(vec2 uv,float t,float bend){\n\n    float angle_offset = mod(sin(t),pit) - bend;\n    vec2 v0 = vec2(cos(a0-angle_offset)*r,sin(a0-angle_offset)*r);\n    vec2 v1 = vec2(cos(a1-angle_offset)*r,sin(a1-angle_offset)*r);\n    vec2 v2 = vec2(cos(a2-angle_offset)*r,sin(a2-angle_offset)*r);\n    return sdTriangle( v0, v1, v2, uv);   \n}\n\nvoid main(){\n    float t = iTime;\n    float rot = sin(t);\n    float alpha = clamp(alpha,0.0001,1.0);\n    vec2 uv = -1.0 * vec2(v_uv-0.5)*0.5/alpha;\n    float dist = pow(length(uv*5.0),.5);\n    float twist = (rot/pit) * 6.0;\n    float bend = dist * twist - twist*.75;\n\n\n    float d = drawStar(uv,t,bend);\n    float col = clamp(d*90.0,.0,1.);\n\n    d = drawStar(uv,t+0.5,bend);\n    float col2 = clamp(d*90.0,.0,1.);\n\n    // d = drawStar(uv,-t*.5,bend);\n    // float col3 = clamp(d*90.0,.0,1.);\n\n\n\n    gl_FragColor = vec4(vec3(0.25+col2*0.2,0.25+col2*0.3,0.25+col2*0.35),1.0-col);\n}"}]);
//# sourceMappingURL=lerp-logo.js.map